#--
# DO NOT MODIFY!!!!
# This file is automatically generated by rex 1.0.7
# from lexical definition file "lexer.rex".
#++

require 'racc/parser'
require_relative "utils.rb"
class BlangLexer < Racc::Parser
      require 'strscan'

      class ScanError < StandardError ; end

      attr_reader   :lineno
      attr_reader   :filename
      attr_accessor :state

      def scan_setup(str)
        @ss = StringScanner.new(str)
        @lineno =  1
        @state  = nil
      end

      def action
        yield
      end

      def scan_str(str)
        scan_setup(str)
        do_parse
      end
      alias :scan :scan_str

      def load_file( filename )
        @filename = filename
        File.open(filename, "r") do |f|
          scan_setup(f.read)
        end
      end

      def scan_file( filename )
        load_file(filename)
        do_parse
      end


        def next_token
          return if @ss.eos?

          # skips empty actions
          until token = _next_token or @ss.eos?; end
          token
        end

        def _next_token
          text = @ss.peek(1)
          @lineno  +=  1  if text == "\n"
          token = case @state
            when nil
          case
                  when (text = @ss.scan(/\r/))
                    ;

                  when (text = @ss.scan(/\A(\|\||&&|==|!=|<=|>=)/))
                     action { [text, text]}

                  when (text = @ss.scan(/အကယ်၍/))
                     action { [:BIF, "if"]}

                  when (text = @ss.scan(/မှန်/))
                     action { [:BTRUE, "true"]}

                  when (text = @ss.scan(/မှား/))
                     action { [:BFALSE, "false"]}

                  when (text = @ss.scan(/true/))
                     action { [:BTRUE, "true"]}

                  when (text = @ss.scan(/false/))
                     action { [:BFALSE, "false"]}

                  when (text = @ss.scan(/\A"([^"]*)"/))
                     action { [:BSTRING, text.gsub('"', '')]}

                  when (text = @ss.scan(/နတ္ထိ/))
                     action { [:BNIL, "nil"] }

                  when (text = @ss.scan(/မဖြစ်မချင်း/))
                     action { [:BWHILE,"while"]}

                  when (text = @ss.scan(/([\u1040-\u1049]+)/))
                     action { [:BNUMBER, text.myanmar_numbers_to_english.to_i]}

                  when (text = @ss.scan(/\d+/))
                     action { [:BNUMBER, text.myanmar_numbers_to_english.to_i] }

                  when (text = @ss.scan(/\n/))
                     action { [:NEWLINE,:NEWLINE] }

                  when (text = @ss.scan(/အခန်း/))
                     action {[:BCLASS,"class"]}

                  when (text = @ss.scan(/[ \t]+/))
                    ;

                  when (text = @ss.scan(/ကြေညာချက်(\s+)/))
                     action { [:BDEF,"def"] }

                  when (text = @ss.scan(/ပြီး/))
                     action { [:BEND,"end"] }

                  when (text = @ss.scan(/[a-zA-Z]+/))
                     action { [:BIDENTIFIER, text] }

                  when (text = @ss.scan(/([\u1000-\u109F]+)/))
                     action { [:BIDENTIFIER, text] }

                  when (text = @ss.scan(/./))
                     action { [text, text] }

          
          else
            text = @ss.string[@ss.pos .. -1]
            raise  ScanError, "can not match: '" + text + "'"
          end  # if

        else
          raise  ScanError, "undefined state: '" + state.to_s + "'"
        end  # case state
          token
        end  # def _next_token

end # class
